import axios from "axios";
import { ApiError } from "../utils/errors";
import { logger } from "../utils/logger";
import { parseISO, formatDuration } from "date-fns";

class YouTubeService {
  constructor() {
    this.apiClient = axios.create({
      baseURL:
        process.env.YOUTUBE_API_BASE_URL ||
        "https://www.googleapis.com/youtube/v3",
      timeout: 10000,
      headers: {
        "Content-Type": "application/json",
      },
    });

    this.apiKey = process.env.YOUTUBE_API_KEY;
  }

  async getVideoInfo(videoId) {
    try {
      const response = await this.apiClient.get("/videos", {
        params: {
          part: "snippet,contentDetails,statistics",
          id: videoId,
          key: this.apiKey,
        },
      });

      if (!response.data.items || response.data.items.length === 0) {
        throw new ApiError("Video not found", 404);
      }

      const videoData = response.data.items[0];
      const { snippet, contentDetails, statistics } = videoData;

      return {
        id: videoId,
        title: snippet.title,
        description: snippet.description,
        author: snippet.channelTitle,
        thumbnailUrl:
          snippet.thumbnails.maxres?.url || snippet.thumbnails.high.url,
        publishDate: parseISO(snippet.publishedAt),
        duration: this.formatDuration(contentDetails.duration),
        views: parseInt(statistics.viewCount, 10),
        likes: parseInt(statistics.likeCount, 10),
        hasTranscript: await this.checkTranscriptAvailability(videoId),
        availableLanguages: await this.getAvailableTranscriptLanguages(videoId),
      };
    } catch (error) {
      logger.error("Error fetching video info:", error);
      if (error instanceof ApiError) throw error;
      throw new ApiError(
        error.response?.data?.error?.message || "Failed to fetch video info",
        error.response?.status || 500
      );
    }
  }

  async getTranscript(videoId, languageCode = "en") {
    try {
      const response = await this.apiClient.get("/captions", {
        params: {
          part: "snippet",
          videoId: videoId,
          key: this.apiKey,
        },
      });

      if (!response.data.items || response.data.items.length === 0) {
        throw new ApiError("No captions found for this video", 404);
      }

      const caption = response.data.items.find(
        (item) => item.snippet.language === languageCode
      );

      if (!caption) {
        throw new ApiError(`No captions available in ${languageCode}`, 404);
      }

      const transcriptResponse = await this.apiClient.get(
        `/captions/${caption.id}`,
        {
          params: {
            tfmt: "srt",
            key: this.apiKey,
          },
        }
      );

      return {
        transcript: this.parseSrtTranscript(transcriptResponse.data),
        language: languageCode,
        isAutoGenerated: caption.snippet.trackKind === "ASR",
      };
    } catch (error) {
      logger.error("Error fetching transcript:", error);
      if (error instanceof ApiError) throw error;
      throw new ApiError(
        error.response?.data?.error?.message || "Failed to fetch transcript",
        error.response?.status || 500
      );
    }
  }

  async checkTranscriptAvailability(videoId) {
    try {
      const response = await this.apiClient.get("/captions", {
        params: {
          part: "snippet",
          videoId: videoId,
          key: this.apiKey,
        },
      });

      return response.data.items && response.data.items.length > 0;
    } catch (error) {
      logger.error("Error checking transcript availability:", error);
      return false;
    }
  }

  async getAvailableTranscriptLanguages(videoId) {
    try {
      const response = await this.apiClient.get("/captions", {
        params: {
          part: "snippet",
          videoId: videoId,
          key: this.apiKey,
        },
      });

      if (!response.data.items) return [];

      return response.data.items.map((item) => ({
        code: item.snippet.language,
        name: this.getLanguageName(item.snippet.language),
        isAutoGenerated: item.snippet.trackKind === "ASR",
      }));
    } catch (error) {
      logger.error("Error fetching available languages:", error);
      return [];
    }
  }

  formatDuration(isoDuration) {
    try {
      const duration = formatDuration(isoDuration);
      return duration.replace("PT", "").toLowerCase();
    } catch (error) {
      logger.error("Error formatting duration:", error);
      return "unknown";
    }
  }

  parseSrtTranscript(srtContent) {
    try {
      const segments = srtContent.trim().split("\n\n");
      let transcript = "";

      segments.forEach((segment) => {
        const lines = segment.split("\n");
        if (lines.length >= 3) {
          transcript += lines.slice(2).join(" ") + " ";
        }
      });

      return transcript.trim();
    } catch (error) {
      logger.error("Error parsing SRT transcript:", error);
      throw new ApiError("Failed to parse transcript", 500);
    }
  }

  getLanguageName(languageCode) {
    const languages = new Intl.DisplayNames(["en"], { type: "language" });
    try {
      return languages.of(languageCode);
    } catch (error) {
      return languageCode;
    }
  }
}

export const youtubeService = new YouTubeService();
